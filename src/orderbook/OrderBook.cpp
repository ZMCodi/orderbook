#include "orderbook/OrderBook.h"
#include <iostream>

const order_list OrderBook::emptyOrders{};

bool OrderAudit::equals_to(const OrderAudit& other) const
{
    return id == other.id
    && volume_delta == other.volume_delta;
}

bool OrderBook::Level::operator==(const Level& other) const
{
    return std::abs(price - other.price) < 0.0001
    && volume == other.volume
    && orderCount == other.orderCount;
}

bool OrderBook::Depth::operator==(const Depth& other) const
{
    return bids == other.bids
    && asks == other.asks
    && volume == other.volume
    && std::abs(bestBid - other.bestBid) < 0.0001
    && std::abs(bestAsk - other.bestAsk) < 0.0001
    && std::abs(marketPrice - other.marketPrice) < 0.0001;
}

OrderResult OrderBook::placeOrder(Order& order, callback callbackFn)
{
    if (order.volume <= 0) 
    {
        throw std::invalid_argument{"Volume has to be positive"};
    }

    // generate a unique id and timestamp for the order
    auto id{utils::uuid_generator()};
    time_ ts{utils::now()};

    // store in id pool for persistent storage and get pointer
    auto [it, _] = idPool.insert(id);

    // stamp the original order object first
    order.id = &(*it);
    order.timestamp = ts;
    orderList.push_back(order); // bookkeeping

    // for market orders, no need for a copy
    if (order.type == Order::Type::MARKET) {return matchOrder(order);}

    // local active copy that is actually processed with truncated price
    Order activeCopy{order, tickSize};
    if (callbackFn) {activeCopy.callbackFn = callbackFn;}
    double truncPrice{activeCopy.price};
    tick_t tickPrice{utils::convertTick(truncPrice, tickSize)};

    // match with existing orders and return result
    auto result{matchOrder(activeCopy)};

    // if order remains unfilled
    if (activeCopy.volume > 0)
    {
        // update relevant fields
        totalVolume += activeCopy.volume;

        // put in bid/ask map
        // some code duplication here since bid_map and ask_map are diff types
        order_list::iterator activeItr;
        if (activeCopy.side == Order::Side::BUY)
        {
            // update best bid if better
            if (activeCopy.price > bestBid) {bestBid = activeCopy.price;}

            // add the order to the end of the orderlist
            // and update volume at PriceLevel
            auto& pLevel{bidMap[tickPrice]}; // creates an empty PriceLevel if doesnt exist
            pLevel.volume += activeCopy.volume;
            pLevel.orders.push_back(std::move(activeCopy));
            activeItr = std::prev(pLevel.orders.end());
        } else
        {
            // update best ask if better
            if (bestAsk == -1 || activeCopy.price < bestAsk) {bestAsk = activeCopy.price;}

            auto& pLevel{askMap[tickPrice]};
            pLevel.volume += activeCopy.volume;
            pLevel.orders.push_back(std::move(activeCopy));
            activeItr = std::prev(pLevel.orders.end());
        }

        // add to idMap
        idMap[order.id] = OrderLocation{truncPrice, activeItr, order.side};
        result.remainingOrder = &(*activeItr); // result points to remaining order
    }

    return result;
}

OrderResult OrderBook::placeOrder(Order&& order, callback callbackFn)
{
    return placeOrder(order, callbackFn);
}

// core matching logic
OrderResult OrderBook::matchOrder(Order& order)
{
    // default result if limit order is not matched
    OrderResult default_{*order.id, OrderResult::PLACED, trades{}, nullptr, "Order placed"};
    trades generatedTrades{}; // trades generated by the match

    // limit buy
    if (order.type == Order::Type::LIMIT && order.side == Order::Side::BUY)
    {
        return matchLimitBuy(order, generatedTrades, default_);
    }

    // limit sell
    if (order.type == Order::Type::LIMIT && order.side == Order::Side::SELL)
    {
        return matchLimitSell(order, generatedTrades, default_);
    }

    // market buy
    if (order.type == Order::Type::MARKET && order.side == Order::Side::BUY)
    {
        return matchMarketBuy(order, generatedTrades);
    }

    return default_;
}

OrderResult OrderBook::matchLimitBuy(Order& order, trades& generatedTrades, OrderResult& default_)
{
    if (bestAsk == -1 || order.price < bestAsk) {return default_;} // doesn't cross spread or no asks

    int oriVol{order.volume}; // save this here for result

    // start at bestAsk
    for (auto mapIt{askMap.begin()}; mapIt != askMap.end();/*increment logic is complex*/)
    {
        // order has filled all orders below its price
        if (mapIt->first * tickSize > order.price) {break;}

        // iterate through orders at the level
        auto& orders{mapIt->second.orders};
        for (auto orderIt{orders.begin()}; orderIt != orders.end();/*increment logic is complex*/)
        {
            auto& o{*orderIt}; // the current order being matched against
            if (order.volume >= o.volume) // order gets partial filled by o
            {
                order.volume -= o.volume;
                genTrade(order, o, o.price, o.volume, order.side, generatedTrades);

                // remove o since its matched
                idMap.erase(o.id); // from idMAP
                mapIt->second.volume -= o.volume; // volume at PriceLevel
                totalVolume -= o.volume;
                orderIt = orders.erase(orderIt); // orders at PriceLevel and increment iterator

            } else if (order.volume < o.volume) // order gets fully filled by o
            {
                o.volume -= order.volume;
                genTrade(order, o, o.price, order.volume, order.side, generatedTrades);

                // order is filled
                mapIt->second.volume -= order.volume; // volume at PriceLevel
                order.volume = 0;
            }

            if (order.volume == 0) {break;} // order already filled
        }

        // clear the level and increment iterator if no more orders
        if (mapIt->second.orders.empty()) {mapIt = askMap.erase(mapIt);}
        else {++mapIt;}
    }

    // update bestAsk
    if (askMap.empty()) {bestAsk = -1;}
    else {bestAsk = askMap.begin()->first * tickSize;}

    // return OrderResult
    if (order.volume == 0) // fully filled
    {
        return {*order.id, OrderResult::FILLED, generatedTrades, nullptr, "Order filled"};
    } else // partially filled
    {
        std::stringstream msg;
        msg << "Partially filled " << oriVol - order.volume << " shares, "
        << order.volume << " shares remaining";
        return {*order.id, OrderResult::PARTIALLY_FILLED, generatedTrades, nullptr, msg.str()};
    }
}

OrderResult OrderBook::matchLimitSell(Order& order, trades& generatedTrades, OrderResult& default_)
{
    if (bestBid == -1 || order.price > bestBid) {return default_;} // doesn't cross spread or no bids

    int oriVol{order.volume};

    // start at bestBid
    for (auto mapIt{bidMap.begin()}; mapIt != bidMap.end();)
    {
        // all orders above the price is filled
        if (mapIt->first * tickSize < order.price) {break;}

        auto& orders{mapIt->second.orders};
        for (auto orderIt{orders.begin()}; orderIt != orders.end();)
        {
            auto& o{*orderIt};
            if (order.volume >= o.volume) // order gets partial filled
            {
                order.volume -= o.volume;
                genTrade(o, order, o.price, o.volume, order.side, generatedTrades);

                // remove o since its matched
                idMap.erase(o.id);
                mapIt->second.volume -= o.volume;
                totalVolume -= o.volume;
                orderIt = orders.erase(orderIt);

            } else if (order.volume < o.volume) // order gets fully filled
            {
                o.volume -= order.volume;
                genTrade(o, order, o.price, order.volume, order.side, generatedTrades);

                mapIt->second.volume -= order.volume;
                order.volume = 0;
            }

            if (order.volume == 0) {break;} // order filled
        }

        // clear level if no more orders left
        if (mapIt->second.orders.empty()) {mapIt = bidMap.erase(mapIt);}
        else {++mapIt;}
    }

    // update bestBid
    if (bidMap.empty()) {bestBid = -1;}
    else {bestBid = bidMap.begin()->first * tickSize;}

    // return OrderResult
    if (order.volume == 0) // fully filled
    {
        return {*order.id, OrderResult::FILLED, generatedTrades, nullptr, "Order filled"};
    } else // partially filled
    {
        std::stringstream msg;
        msg << "Partially filled " << oriVol - order.volume << " shares, "
        << order.volume << " shares remaining";
        return {*order.id, OrderResult::PARTIALLY_FILLED, generatedTrades, nullptr, msg.str()};
    }
}

OrderResult OrderBook::matchMarketBuy(Order& order, trades& generatedTrades)
{
    if (bestAsk == -1) // no asks
    {
        return {*order.id, OrderResult::REJECTED, trades{}, nullptr, "Not enough liquidity"};
    }

    int oriVol{order.volume};

    // start at bestAsk
    for (auto mapIt{askMap.begin()}; mapIt != askMap.end();)
    {
        auto& orders{mapIt->second.orders};
        for (auto orderIt{orders.begin()}; orderIt != orders.end();)
        {
            auto &o{*orderIt};
            if (order.volume >= o.volume) // order gets partial filled by o
            {
                order.volume -= o.volume;
                genTrade(order, o, o.price, o.volume, order.side, generatedTrades);

                // remove o
                idMap.erase(o.id);
                mapIt->second.volume -= o.volume;
                totalVolume -= o.volume;
                orderIt = orders.erase(orderIt);

            } else if (order.volume < o.volume) // order gets fully filled by o
            {
                o.volume -= order.volume;
                genTrade(order, o, o.price, order.volume, order.side, generatedTrades);

                mapIt->second.volume -= order.volume;
                order.volume = 0;
            }

            if (order.volume == 0) {break;}
        }

        if (mapIt->second.orders.empty()) {mapIt = askMap.erase(mapIt);}
        else {++mapIt;}
    }

    // update bestAsk
    if (askMap.empty()) {bestAsk = -1;}
    else {bestAsk = askMap.begin()->first * tickSize;}

    // return OrderResult
    if (order.volume == 0) // fully filled
    {
        return {*order.id, OrderResult::FILLED, generatedTrades, nullptr, "Order filled"};
    } else // partially filled
    {
        std::stringstream msg;
        msg << "Partially filled " << oriVol - order.volume << " shares, remaining order cancelled";
        return {*order.id, OrderResult::PARTIALLY_FILLED, generatedTrades, nullptr, msg.str()};
    }
}


void OrderBook::genTrade(const Order& buyer, const Order& seller, double price,
                        int volume, Order::Side side, trades& generatedTrades)
{
    auto tradeId{utils::uuid_generator()};
    auto [it, _] = idPool.insert(tradeId);
    Trade trade{&(*it), buyer.id, seller.id, price, volume, utils::now(), side};
    generatedTrades.push_back(trade);

    // trigger callbacks
    buyer.notify(trade);
    seller.notify(trade);

    // internal bookkeeping
    tradeList.push_back(trade);
    marketPrice = price;
}

OrderResult OrderBook::cancelOrder(const uuids::uuid* id)
{
    return {*id, OrderResult::FILLED, trades(), nullptr, ""};
}

OrderResult OrderBook::modifyVolume(const uuids::uuid* id, int volume)
{
    [[maybe_unused]] auto lol = volume * 2;
    return {*id, OrderResult::FILLED, trades(), nullptr, ""};
}

OrderResult OrderBook::modifyPrice(const uuids::uuid* id, double price)
{
    [[maybe_unused]] auto lol = price * 2;
    return {*id, OrderResult::FILLED, trades(), nullptr, ""};
}

OrderResult OrderBook::cancelOrder(const uuids::uuid& id)
{
    return {id, OrderResult::FILLED, trades(), nullptr, ""};
}

OrderResult OrderBook::modifyVolume(const uuids::uuid& id, int volume)
{
    [[maybe_unused]] auto lol = volume * 2;
    return {id, OrderResult::FILLED, trades(), nullptr, ""};
}

OrderResult OrderBook::modifyPrice(const uuids::uuid& id, double price)
{
    [[maybe_unused]] auto lol = price * 2;
    return {id, OrderResult::FILLED, trades(), nullptr, ""};
}

bool OrderBook::registerCallback(const uuids::uuid* id, callback callbackFn)
{
    // check if order is still active
    auto it{idMap.find(id)};

    if (it == idMap.end()) {return false;} // order is no longer active

    it->second.itr->callbackFn = callbackFn; // assign the callback
    return true;
}

bool OrderBook::registerCallback(const uuids::uuid& id, callback callbackFn)
{
    // find uuid in idPool first and get pointer
    auto it{idPool.find(id)};

    if (it == idPool.end()) {return false;} // not a valid uuid

    return registerCallback(&(*it), callbackFn);
}

bool OrderBook::removeCallback(const uuids::uuid* id)
{
    // check if order is still active
    auto it{idMap.find(id)};

    if (it == idMap.end()) {return false;} // order is no longer active

    it->second.itr->callbackFn = nullptr; // assign the callback
    return true;
}

bool OrderBook::removeCallback(const uuids::uuid& id)
{
    // find uuid in idPool first and get pointer
    auto it{idPool.find(id)};

    if (it == idPool.end()) {return false;} // not a valid uuid

    return removeCallback(&(*it));
}

const order_list& OrderBook::bidsAt(double priceLevel)
{
    tick_t tickPrice{utils::convertTick(priceLevel, tickSize)};
    auto it{bidMap.find(tickPrice)};

    // if no bids, return empty list
    if (it == bidMap.end())
    {
        return OrderBook::emptyOrders;
    }

    return it->second.orders;
}

const order_list& OrderBook::asksAt(double priceLevel)
{
    tick_t tickPrice{utils::convertTick(priceLevel, tickSize)};
    auto it{askMap.find(tickPrice)};

    // if no asks, return empty list
    if (it == askMap.end())
    {
        return OrderBook::emptyOrders;
    }

    return it->second.orders;
}

const Order& OrderBook::getOrderByID(const uuids::uuid* id)
{
    try
    {
        return *idMap.at(id).itr;
    } catch (const std::out_of_range&)
    {
        throw std::invalid_argument{"Order is no longer active"};
    }
}

const Order& OrderBook::getOrderByID(const uuids::uuid& id)
{
    // look in the idPool first if the id exists
    auto it{idPool.find(id)};

    if (it == idPool.end())
    {
        throw std::invalid_argument{"ID does not exist"};
    }

    return getOrderByID(&(*it));
}

int OrderBook::volumeAt(double priceLevel)
{
    tick_t tickPrice{utils::convertTick(priceLevel, tickSize)};
    // determine to check at bidMap or askMap
    if (priceLevel <= bestBid)
    {
        auto it{bidMap.find(tickPrice)};
        if (it != bidMap.end())
        {
            return it->second.volume;
        }
    } else if (priceLevel >= bestAsk)
    {
        auto it{askMap.find(tickPrice)};
        if (it != askMap.end())
        {
            return it->second.volume;
        }
    }

    return 0;
}

// OPTIMIZE: this could probably be just one loop
// center around best bid/ask
OrderBook::Depth OrderBook::getDepth(size_t levels)
{
    // get bids first
    std::vector<OrderBook::Level> bids{};
    size_t i{};
    for (auto it{bidMap.begin()}; it != bidMap.end(); ++it)
    {
        if (i >= levels) {break;}
        bids.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        ++i;
    }

    // get asks
    std::vector<OrderBook::Level> asks{};
    i = 0;
    for (auto it{askMap.begin()}; it != askMap.end(); ++it)
    {
        if (i >= levels) {break;}
        asks.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        ++i;
    }

    return {bids, asks, totalVolume, bestBid, bestAsk, marketPrice};
}

// center around a given price
OrderBook::Depth OrderBook::getDepthAtPrice(double price, size_t levels)
{
    std::vector<OrderBook::Level> bids{};
    std::vector<OrderBook::Level> asks{};

    if (price < bestBid) // centered around a bid price
    {
        // start at best bid and go until `levels` levels below the price
        // iterate and find the level of the price after it (in case the price itself doesnt exist)
        auto endIt{bidMap.begin()};
        while (endIt != bidMap.end())
        {
            if (endIt->first * tickSize < price) // found the first level after
            {
                // move it the remaining levels
                // it should end one step over for a half open range
                if (std::distance(endIt, bidMap.end()) >= static_cast<int>(levels))
                {
                    // make sure we dont advance past the end iterator here
                    std::advance(endIt, levels);
                } else
                {
                    endIt = bidMap.end();
                }
                break;
            }
            ++endIt;
        }

        // bids should be everything from best bid to the end iterator
        for (auto it{bidMap.begin()}; it != endIt; ++it)
        {
            bids.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        }

        size_t i{};
        // for asks just go `levels` level from best ask
        for (auto it{askMap.begin()}; it != askMap.end(); ++it)
        {
            if (i >= levels) {break;}
            asks.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
            ++i;
        }

    } else if (price > bestAsk) // centered around an ask price
    {
        // logic here is basically the same
        auto endIt{askMap.begin()};
        while (endIt != askMap.end())
        {
            if (endIt->first * tickSize > price)
            {
                if (std::distance(endIt, askMap.end()) >= static_cast<int>(levels))
                {
                    std::advance(endIt, levels);
                } else
                {
                    endIt = askMap.end();
                }
            }
            ++endIt;
        }

        for (auto it{askMap.begin()}; it != endIt; ++it)
        {
            asks.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        }

        size_t i{};
        for (auto it{bidMap.begin()}; it != bidMap.end(); ++it)
        {
            if (i >= levels) {break;}
            bids.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
            ++i;
        }

    } else // centered around best bid/ask or gap in between
    {
        return getDepth(levels);
    }

    return {bids, asks, totalVolume, bestBid, bestAsk, marketPrice};
}

// depth in a given range
OrderBook::Depth OrderBook::getDepthInRange(double minPrice, double maxPrice)
{
    std::vector<OrderBook::Level> bids{};
    std::vector<OrderBook::Level> asks{};

    if (maxPrice >= bestAsk && minPrice >= bestAsk) // whole range is just in asks
    {
        for (auto it{askMap.begin()}; it != askMap.end(); ++it)
        {
            if (it->first * tickSize < minPrice) {continue;} // not yet reached min
            if (it->first * tickSize > maxPrice) {break;} // overshot max
            asks.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        }

    } else if (minPrice <= bestBid && maxPrice <= bestBid) // whole range just in bids
    {
        for (auto it{bidMap.begin()}; it != bidMap.end(); ++it)
        {
            if (it->first * tickSize < minPrice) {continue;} // not yet reached min
            if (it->first * tickSize > maxPrice) {break;} // overshot max
            asks.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        }

    } else // go from best ask to max and best bid to min
    {
        for (auto it{askMap.begin()}; it != askMap.end(); ++it)
        {
            if (it->first * tickSize > maxPrice) {break;}
            asks.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        }

        for (auto it{bidMap.begin()}; it != bidMap.end(); ++it)
        {
            if (it->first * tickSize < minPrice) {break;}
            bids.emplace_back(it->first * tickSize, it->second.volume, it->second.orders.size());
        }
    }

    return {bids, asks, totalVolume, bestBid, bestAsk, marketPrice};
}
