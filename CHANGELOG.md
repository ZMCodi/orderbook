# This is an unofficial changelog I keep to document the trials and tribulations of this project

## UUID handling
This was the first bump in the road that was annoying as hell. The problem was to manage UUID ownership for `Order` and `Trade` structs while trying to optimize memory (and time) as much as possible.

### v1
At the start, I had the `Order` object initialize its `id` upon creation using the `uuid_generator` and then converting this to string using the `uuids::to_string` method. Then when an order is matched, it would generate a `Trade` object that holds a `string_view` to the buyer and seller `Order`'s `id` fields while also storing its own trade `id` which is a string again generated by the `uuid_generator`.

Clearly, this comes with some problems:
1. `std::string` itself is large and the UUID string is a 36-character array which totals up to ~60 bytes (24 + 36)
2. When an `Order` is matched, it gets removed from from the `OrderBook` since there's no use for it anymore. If the user doesn't store a reference to the `Order` object, it gets deallocated along with its UUID string hence leaving the `string_view`s in `Trade` and `OrderResult` dangling. The latter is not that big of a problem but `Trade`s are stored in the `OrderBook`'s `tradeList` so that's definitely a problem.

### v2
Clearly something had to be done regarding the UUID persistence and its size overhead. The easiest solution was to just have `Trade` and `OrderResult` store copies of the UUID's they are referencing but that would mean a `Trade` would be at least 180 bytes and that is unacceptable since this is not Python.

Looking back, in a day, a blue-chip stock would have around 150K trades a day and that would only total up to 30MB worth of trades for an orderbook per day which is acceptable. But then again, why code in C++ if I'm not gonna fuss over memory optimization. Also, less copying -> faster execution and that's definitely important for HFT.

The first solution was to use an `uint64_t` based internal mapping (I'll just say int from now) for the objects and then store the UUID strings in an `idPool` map in the `OrderBook` itself. So now, instead of an `Order` and a `Trade` having a UUID string, it just holds an int that maps to a UUID string. Also, any references to a UUID can be represented by an 8 byte int instead of a 16 byte `string_view`. This way, we solve both problems from before:
1. An int is only 8 bytes which is much smaller compared to a `std::string`
2. Even if an `Order` gets deallocated, its UUID string would still be stored in the `OrderBook` so there's no risk of dangling references in `Trade` and `OrderResult` objects

In essence, `Order`s and `Trade`s would be managed internally using an int but an API would still return a UUID string when these objects are returned. Also, this means that `Order` cannot initialize a UUID in its constructor anymore. Instead, when it is placed, the `OrderBook` assigns an int internal id, generate a UUID string and store this mapping in `idPool`.

### v3
Could have called it a day there but we can do better. One thing I realized after skimming through the [uuid library](include/libraries/uuid.h) is that the `uuids::uuid` objects themselves are actually just 16-byte int arrays which is half as small as their string representations! Why bother storing UUID string when I can store the `uuids::uuid` arrays directly and that's what I did. So I swapped all UUID strings to `uuids::uuid` and we all lived happily ever after.

### v4
I soon came to realize there was an unnecessary level of indirection and internal mapping here. Why should I use an internal int mapping when I can just store pointers to the `uuids::uuid` objects instead? So instead of going to `idPool` and finding the UUID that corresponds to the int id, just dereference the pointer. Eureka!

So I removed all internal int id implementation, and make everyone just store pointers to their `uuids::uuid` in `idPool` which is now an `unordered_set` instead of an `unordered_map` since we don't need the int keys anymore and we all lived happily ever after (hopefully)
